---
author: Albert
date: 2024-02-22
date created: 2024-01-10
date updated: 2024-01-10 16:05
description: 计算机网络常识
tags:
  - network
  - interview
title: 计算机网络-HTTP缓存相关的请求头
---

# 计算机网络-HTTP缓存相关的请求头

## 1. 常见的请求头

- `Cache-Control` 定义了所有缓存机制必须遵循的缓存指令
- `Expries` 定义资源的过期时间 （`Http1.0` 当中使用的，尽量考虑采用 `max-age` 去替代，但是部分场景下不兼容，所以在 `nginx` 配置方面，还是需要加上的）
---
- `Etag` 资源标识符，用来表示资源的完整性，即资源是否被修改
- `If-None-Match` 客户端用来携带资源上一次请求得到的 `Etag`，服务器会比较这个 `Etag` 和当前资源的 `Etag`，如果一致，那么就返回 `304`，如果不一致，那么就说明资源已经被 修改了。
---
- `If-Modified-Since` 客户端用来提供上一次请求资源的时候服务器返回的最后修改时间，服务器会比较这个时间，和服务器上面保存的最后一次修改时间，如果资源修改过，返回新的资源，否则返回 `304` 状态，表示资源没有被修改。
- `Last-Modified` 服务器在响应中提供这个头，表示资源的最后修改时间，客户端下次请求的时候会带上，用来和服务器校对资源修改情况，用以后续判断。

## 2. `Cache-Control` 响应头字段

- **缓存控制策略的定义者**，所谓缓存策略，本质上就是解决三个问题
    1. 资源要不要缓存
    2. 资源何时缓存
    3. 如果去做资源的缓存

### 2.1 `no-cache`

- 服务端发送给浏览器的报文中，如果头部定义 `Cache-Control: no-cache`，**相当于告诉浏览器，不要*直接*从缓存当中取资源，应该和服务器验证一下，缓存是否是最新的（资源是否被修改）**
- *不是说不要缓存，而且在进行缓存前，需要确认缓存的有效性*

### 2.2 `no-store`

- 服务器发送指令告诉浏览器，**全面禁止浏览器和CDN等中间缓存，存储任何版本的缓存响应**
- 服务器发送这个指令的言下之意是：所发送的数据是*敏感的，不能被缓存在任何中间层当中*
- 用户每次请求，都是直接从服务器去获取资源

### 2.3 `max-age`

- 服务器告诉浏览器和所有缓存中间层，**我们现在确定资源有效性的办法是*通过时间*，*不必进行其他的有效性*验证**。
- 这个服务器响应头，是在 `HTTP 1.1` 当中提出的，用来取代 `Expires` 头，因为 `max-age` 可以提供更加简洁的控制机制。`Expires` 需要依赖客户端和服务器设置的时间一致。
- `max-age=0` 通常用于强制浏览器每次都确认资源的有效性，但并不完全禁止使用缓存，只是每次使用前都需要确认。

### 2.4 `public/private`

- 响应头的 `Cache-Contorl: private` 相当于告诉告诉客户端，**只允许浏览器进行缓存，不允许代理服务器和 CDN 等其他中间者缓存相应的资源**。
- 响应头的 `Cache-Contorl: publice` 相当于告诉告诉客户端，**允许其他的中间层和代理服务器等等去共享缓存内容**。

### 2.5 `no-transform`

- 禁止中间层的其他缓存服务器修改资源的格式
---

- 整体而言，可以通过下图做简单的判断

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20240110151537.png)

- 是否进行缓存 `no-store`
- 缓存是否需要验证 `no-cache`
- 缓存是否允许中间层参与 `private/public`
- 缓存过期时间 `max-age`

## 3. `Etag` 响应头字段

- 首先，明确一个概念，`Etag` 是资源完整性的一个验证，**只有在双方需要确认缓存资源是否可复用的时候，才需要 `Etag` 参与**
- **只有响应头才会携带 `Etag` 资源完整性验证**
- 利用摘要算法，计算出资源的状态，用 `Etag` 的数值去记录。
- 如果请求头当中的 `Etag` 发生了变化，那么资源就无法从缓存当中获取，如果没有变化，直接返回 `304`，告诉浏览器，你用本地的就可以了。

## 4. `If-None-Match` 请求头字段

- *只有请求头才会携带 `If-None-Match` 字段*
- *只有双方在协商资源是否可以复用的时候，才会用到 `If-None-Match`* 字段
- 这个字段里面值，一般就是浏览器本地所存放的**上次服务端发送过来的 `Etag` 数值**。
- 通过 `If-None-Match` 携带的哈希值，和服务端的实时验证的哈希值去做对比，判断缓存是否可用。
  - `304` 的含义：*服务器说：我确定当前客户端资源的缓存是最新的，客户端可以放心去使用*
---

## 5. `Last-Modified` 响应头字段

- *这个响应头字段里面存放的是时间，一般是服务端首次传输资源的时候，告诉客户端，我最后一次更新的时间是多少*
- 其作用有点类似 `Etag`，只不过 `Etag` 依靠的是哈希去计算，`Last-Modified` 依赖的是最后一次修改时间。准确性来说，依靠时间计算不见得完全准确，其基本单位是**秒**，如果一秒内发生变化，其变化无法通过 `Last-Modified` 的数值反馈出来。

## 6. `If-Modified-Since` 请求头字段

- 这个请求头字段存放的是**客户端上次从服务器那里拿到的资源最后一次修改的时间**。
- 和 `Last-Modified-Since` 进行配合使用，如果拿到的资源最后一次修改时间，和服务端存储的最后一次修改时间没有区别，那么缓存就可以继续使用，返回 `304`，否则重新发送资源。

## 6. 完整性验证：依靠时间还是依靠哈希

- `Last-Modified` 和 `If-Modified-Since` 是一对，基于时间来判断资源是否发生了改变。当资源的最后修改时间大于 `If-Modified-Since` 的时间时，说明资源有更新。
- `Etag` 和 `If-None-Match` 是一对，它们使用的是资源的一种标识（通常是基于资源内容的哈希值）来判断资源是否发生了改变。当资源的 `Etag` 和请求头中的 `If-None-Match` 不匹配时，说明资源有更新。
- 这两种机制都是用来实现条件请求的，避免不必要的数据传输，提高网络效率和缓存利用率。而且，它们可以同时使用，以提供更强的缓存验证机制。
---
- 依靠哈希进行资源完整性验证是更加鲁棒的做法。依赖时间进行验证，往往不够可靠，首先，如果资源在一秒内频繁变化，那么 `Last-Modified` 响应头当中的时间就失去意义了，其次，如果资源在服务端进行迁移，其时间可能会发生混乱。
- 但是，为什么还是需要通过时间进行验证呢？
  1. 为了节约计算资源：哈希值的计算对于 `CPU` 的负载比较大，很可能出现资源不足的情况。
  2. 为了更好的兼容性：部分场景对于 `Etag` 的兼容支持不足。

## 7. 实际场景

### 6.1 资源过期，判断完整性，完整性不变

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20240110153606.png)

### 6.2 资源过期，判断完整性，完整性变化

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20240110153703.png)

