---
author: Albert
date: 2024-03-03
date created: 2023-12-07
date updated: 2023-12-07 17:18
tags:
  - DB
  - Blog
title: 数据库-Redis的SDS结构
---


# 数据库-Redis的SDS结构

## 1. `SDS` 的设计希望解决什么问题

- `Redis` 基于纯 `C` 编码，`SDS` 的设计目的之一是为了规避静态数组的大小限制
- 希望能够常数时间获取数组的大小
- 希望解决 `C` 当中数组的缓冲区溢出问题
- 希望能够减少字符串的内存重新分配次数
- 希望能够兼容二进制的数据，因为 `C` 通过判断空字符 `/0` 去判断字符的长度，但是很多数据结构会穿插空字符 `/0` 在中间，具体可以参考下图。（比如图片或者音频/视频之类的）*设计出来的 `SDS`应当尽力避免这种方式的读取*

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20231207163049.png)

## 2. `SDS` 的数据结构

- 实际上，可以简单地将其看作如下结构

```c
struct sdshdr {
    uint32_t len;    //字符串长度
    uint32_t alloc;  //字符串空间大小
    unsigned char flags; //表示sds的类型（8位）
    char buf[];  //用于存储字符串数据
};
```

- `len` 表示 `buf` 已经使用的空间长度，占 `4` 个字节，因为需要表示 `2^32`（不包括 `\0`）
- `alloc` 表示 `buf` 实际分配的长度，占 `4` 个字节，因为需要表示 `2^32`（不包括 `\0`）
- `flags` 表示当前的 `sds` 是哪一种类型的，占 `1` 个字节， 因为可能有多种类型（ `sdshdr8/16/32/64` ），不同类型长度不同。
- `buf` 是指向实际字节数组的指针，保存实际数据。其长度需要额外添加 `\0`，也就是多加1。（添加 `\0` 的意义是为了兼容原本的 `C` 字符串，不要多做额外的修改）
- 通过这样的结构体可以达到设计的需求。

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20231207163501.png)

---

### 2.1 如何保证数组是动态的

>[!info]
> - `Redis` 基于纯 `C` 编码，`SDS` 的设计目的之一是为了规避静态数组的大小限制

- 预先分配底层数组的空间，然后将字符串写入其中。**字符串可以在运行的时候改变其长度，不必每次修改都创建新的字符串**。
- 将原始 `C` 字符串的 `immutability` 修改为 `mutability` ，也就是可以在原本的字符串的基础上做修改。
- 通过长度 `len` 和 总体空间大小 `alloc` ，能够 `O(1)` 时间计算出*新字符是否需要重新分配空间*。
- 如果需要追加，导致预分配空间不够，那么就会导致扩容操作（一般是近似于倍增扩容）
- 如果字符串缩短，也会保留额外的空间，防止未来增加。

### 2.2 常数时间获悉分配情况

>[!info]
>- 希望能够常数时间获取数组的大小

- 通过 `struct` 当中的 `len` 获悉当前字符串实际使用的空间
- 通过 `strcut` 当中的 `alloc` 获悉当前字符串底层数组分配的空间

### 2.3  解决缓冲区溢出问题

> [!info]
> - 希望解决 `C` 当中数组的缓冲区溢出问题

- 在写入实际数组的时候，会检查空间情况，然后自动扩展底层的长度，*避免写入字符串长度超过预分配大小的问题*
- 维护了明确的长度信息，能够按照实际情况进行内存分配

### 2.4 减少字符串的内存分配次数

> [!info]
> 希望能够减少字符串的内存重新分配次数

- 分配内存的时候采取近似倍增扩容的策略，思想也是很朴素，**一次性多给一点，以降低给的次数**。
- 剩余的 `freespace` 足够容纳 `target_string` 和末尾 `\0` 字符，则不作任何操作
- 剩余的 `freespace` 不够容纳 `target_string` 和末尾的 `\0` 字符
  - 当 `target_string_size` < `1MB`，则会直接分配 `2 * target_string_size` 的空间用于存储字符串
  - 当 `target_string_size` >= `1MB` ，则会再额外多分配 `1MB` 的空间用于存储字符串`(target_string_size + 1024*1024)`

![image.png|475](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20231207170342.png)

---
- 此外，如果字符串长度缩小，其空间释放也是惰性的，也就是 `alloc` 的大小并不变化
- 当 `sds` 字符串缩短时， 空余出来的空间并不会直接释放，而是会被保留，等待下次再次使用。
- 字符串缩短操作需要更新 `sdshdr` 头中的 `Len` 字段以及 `alloced_buffer` 当中的 `\0` 字符的位置。
- **更新字符串长度的过程中并没有涉及到内存的重分配策略，只是简单的修改 `sdshdr` 头中的 Len 字段。**

### 2.5 兼容二进制的数据

- 二进制数据当中本身就包含 `\0`
- 传统的 `C` 字符串并不能区分 `\0` 到底是二进制数据当中的，还是表达结束含义的尾 `\0`。
- 因此，`SDS` 判断字符串是否结束，不是通过尾 `\0`，而是通过计算其长度。
- 那么，为什么还是需要加上 `\0` 呢？是为了能够*兼容 `C` 当中的其他库*，直接把 `SDS` 当中的 `buf` 数组当成字符串去使用。

## 3. `SDS` 的应用

- 用来支撑 `Redis` 当中的 `string` 数据结构，以及其他常见数据结构。

## 4. 总结

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20231207170901.png)
