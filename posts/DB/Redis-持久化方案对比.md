---
author: Albert
date: 2024-03-03
date created: 2024-02-20
date updated: 2024-02-20 22:14
tags:
  - DB
  - Blog
title: Redis-持久化方案对比
---

# Redis-持久化方案对比

> [!tip] >[AOF 持久化是怎么实现的？ | 小林coding](https://xiaolincoding.com/redis/storage/aof.html#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5)

## 1. `AOF` 方案（主流）

### 1.1 原理

- `AOF` 全称为 `append only file`，设计思路上采取了 `log-struct` 的方式，也就是追加式写入。
- 在执行 `redis` 命令的时候，先后执行了两步，第一步是执行命令写入内存，第二步是同步记录日志。（**后写磁盘设计有优势也有劣势**，优势是能够防止写入操作的数据，而且*对写入内存这种关键操作不会造成阻塞*。劣势是如果恰好在写日志之前宕机，有概率造成日志缺失，同时，主线程写磁盘压力过大，可能导致写盘慢，阻塞后续操作。）

### 1.2 优势

- 数据策略比较灵活，近似于*同步持久化*，时间颗粒度更细。
- 采用*增量写入*的方式，如果写入过程当中宕机，也不会破坏日志文件当中已有的内容。
- _文件格式清晰，人类可读_，日志文件基于纯文本，可以按照日志文件恢复内容，并且中间过程易于理解。
- 如果数据过大，也有 `AOF` 日志重写的机制，可以基于 `append` 模式将修改数据写入老的磁盘文件当中，并且这个过程是非阻塞的。

### 1.3 劣势

- `AOF` 的空间消耗比较大，而且恢复大量数据的速度较低。
- 一定程度上牺牲了性能，如果采用实时同步，磁盘 `IO` 会比较频繁，降低了内存型数据库的速度优势。

### 1.4 实操

#### 1.4.1 如何开启 `AOF` 持久化

- 在 `redis.conf` 文件当中，修改以下参数

![image.png](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20240220214234.png)

#### 1.4.2 `AOF` 持久化策略

- `AOF` 可以选择三种持久化策略，本质上是*备份时间颗粒度*和*性能*的取舍

![image.png|475](https://img-20221128.oss-cn-shanghai.aliyuncs.com/img-2023-05/20240220214409.png)

### 1.5 重写机制

#### 1.5.1 如何实现重写

- 重写是为了防止 `AOF` 文件内容体积过大，恢复数据的时候过长，因此，要想办法将 `AOF` 持久化文件体积降低一些。一般而言，日志内容超过 `64MB`，就会触发重写。
- 采用一种朴素的想法，**只保留最新的键值对**，放弃不必要的日志信息。具体的做法是，读取当前数据库的*最新的键值对信息*，然后*重新写到一个新的文件当中*，写完之后，将其*覆盖掉旧的 `AOF`* 文件即可。
- 重写需要通过子进程去完成（避免阻塞父进程）

#### 1.5.2 后台重写

- 后台子进程 `bgrewriteaof` 子进程负责*按照数据库当中的最新键值对，重写一份新的日志文件*。
- 为了防止**在重写 `AOF` 的阶段，恰好有键值对被修改**，`Redis` 设置了一个 `AOF` 重写缓冲区，也就是重写期间，`Redis` 执行写命令的时候，将其同时写入 `AOF` 缓冲区和 `AOF` 重写缓冲区。防止数据不一致。

## 2. `RDB` 方案

### 2.1 原理

- `save` 命令：通过主线程生成 `RDB` 文件，可能存在阻塞风险
- `bgsave` 命令：通过子进程生成 `RDB` 文件，避免主进程阻塞
- `RDB` 本质上是一种**全量**的快照方案，将当前内存数据库当中的内容，以**二进制**的形式写入到磁盘当中。

> - 既然 `bgsave` 不阻塞，为什么不全部都用 `bgsave` ? 会有比较大的内容开销，需要 `fork` 子进程出来。

---

- `Redis` 可以配置来决定，多久执行一次 `bgsave`。（这里也需要注意，如果频率过低，那么备份安全性不足，如果频率过高，那么容易出现性能瓶颈）

### 2.2 数据同步：写时复制

- 如果在执行 `bgsave` 期间，需要保证*主线程能够正常修改数据*。
- `Redis` 解决这个问题的办法就是写时复制，子进程在 `fork` 创建之后，**能够复制父进程的页表**，虽然虚拟内存地址空间不一样，但是**二者共享了同一块内存空间**。
- 如果发生*写入*行为，那么，操作系统就会将内存复制一份出来，复制出来的内容给子进程备份，**不影响主线程正常修改数据**，当然，修改出来的内容只能下一次备份了。当前备份出来的数据是旧的。

### 2.3 优势

- 恢复速度相对 `AOF` 方案较快

### 2.4 劣势

- 同步频率的取舍（频率过高容易出现性能问题，频率过低或许存在安全问题）
- 数据格式是二进制格式，对于人类不可见
- *全量快照*的方案对于性能的负担比较大

## 3. 混合方案

- 希望同时拥有*数据恢复快*和*丢失数据少*这两个优点。
- `Redis 4.0` 之后提出的方案是混合持久化，_混合主要体现在 `AOF` 日志重写的过程_，`AOF` 重写日志的时候， `fork` 出来的子线程会将和主线程共享的内存以 `RDB` 方案写入 `AOF` 文件，然后主线程处理的命令会被记录到 重写缓冲区当中，缓冲区当中的增量命令会以 `AOF` 方式写入到 `AOF` 文件当中。也就是说，文件的格式和 `AOF` 和 `RDB` 混合的。
