---
author: Albert
date: 2024-03-30
date created: 2024-03-30
tags:
  - Blog
  - algorithm
  - acw
  - 贪心
  - 模板题
title: ACW896.最长上升子序列II
---

# ACW896.最长上升子序列II

## 1. 题目

给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 $N$。

第二行包含 $N$ 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

$1 \le N \le 100000$，  
$-10^9 \le 数列中的数 \le 10^9$

#### 输入样例

```
7
3 1 2 1 8 5 6
```

#### 输出样例

```
4
```

## 2. 思路

- 这个题的范围比较大，如果采用 `O(n^2)` 的做法，会出 `TLE`。
- 采用一种贪心的思想，对于数列 `nums` ，希望维护另外一个严格单调增数组 `arr`，将 `nums` 当中的内容逐个放进去，同时，**希望 `arr` 的增长尽量缓慢**。
- 换言之，对于当前 `num`。
  - 如果 `num` 大于 `arr` 最后一个元素，那么就将其放入 `arr`。
  - 如果 `num` 并不大于 `arr` 最后一个元素，那么，就需要找一个位置，将其放进去。认为，`arr` 当中 `>= num` 的数据维护了一个右侧区间，找到这个右侧区间的左端点，将其替换成 `num` 即可。

## 3. 代码

```go
package main

import (
    "fmt"
    "bufio"
    "os"
)

func main() {
    in := bufio.NewReader(os.Stdin)

    var n int
    fmt.Fscan(in, &n)

    var nums = make([]int, n)
    for i := 0; i < n; i++ {
        fmt.Fscan(in, &nums[i])
    }

    var arr = []int{nums[0]}
    for i := 1; i < n; i++ {
        cur := nums[i]

        // case1: > max element in arr
        if cur > arr[len(arr)-1] {
            arr = append(arr, cur)
            continue
        }

        // find replace position
        // > cur's left endpoint
        left, right := 0, len(arr) - 1
        for left < right {
            mid := (left + right) / 2
            if arr[mid] >= cur {
                right = mid
            } else {
                left = mid + 1
            }
        }

        // check if arr[right] > cur
        if left < len(arr) && arr[left] > cur {
            arr[left] = cur
        }
    }

    fmt.Printf("%d", len(arr))
}


```
