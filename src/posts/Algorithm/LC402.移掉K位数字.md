---
author: Albert
date: 2024-03-28
date created: 2023-05-09
tags:
  - Blog
  - 单调栈
  - 模板题
  - Leetcode
title: LC402.移掉K位数字
---

# LC402.移掉K位数字

## 1. 题目

给你一个以字符串表示的非负整数`num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

**示例 1 ：**

```
**输入：** num = "1432219", k = 3
**输出：** "1219"
**解释：** 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

**示例 2 ：**

```
**输入：** num = "10200", k = 1
**输出：** "200"
**解释：** 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**示例 3 ：**

```
**输入：** num = "10", k = 2
**输出：** "0"
**解释：** 从原数字移除所有的数字，剩余为空就是 0 。
```

**提示：**

- `1 <= k <= num.length <= 10^5`
- `num` 仅由若干位数字（0 - 9）组成
- 除了 **0** 本身之外，`num` 不含任何前导零

## 2. 题解

- 对于数位而言，更加关注的是高位（也就是左边的位置）
- 希望数位的前几位能够单调增
- 利用单调栈保持这一点
  - 具体来说，就是**从左往右**将数组元素入栈，如果元素大于等于栈顶，那么正常推入，**如果num(i)小于栈顶元素，那么，就需要将栈顶的元素移除掉**
  - 弹栈的过程，相当于*删除原有数组当中的元素*，因为是从左向右，相当于从高位到低位
  - **_非常经典的模板题，利用单调栈本身的特性_**
- 出栈的次数，最多不超过`k`次

## 3. 代码

```js
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {
  let numStack = []
  for (let digit of num) {
    while (numStack.length > 0 && numStack[numStack.length - 1] > digit && k) {
      numStack.pop()
      k -= 1
    }

    numStack.push(digit)
  }

  while (k > 0) {
    numStack.pop()
    k -= 1
  }

  let res = ''
  while (numStack.length > 0) {
    res = numStack.pop() + res
  }

  // 去除前导0
  if (res == '') {
    res = '0'
  } else {
    for (let i = 0, resLength = res.length; i < resLength; i++) {
      if (res[i] === '0') {
        continue
      } else {
        res = res.slice(i)
        break
      }
    }
  }

  if (res[0] === '0') {
    return '0'
  }
  return res
}
```

---

```go
func removeKdigits(num string, k int) string {
    if k >= len(num) {
        return "0"
    }
    bytes := []byte(num)
    stack := make([]byte, 0, len(bytes))
    for i := 0; i < len(bytes); i++ {
        if len(stack) > 0 && bytes[i] < stack[len(stack) - 1] {
            for k > 0 && len(stack) > 0 && stack[len(stack) - 1] > bytes[i] {
                stack = stack[:len(stack) - 1]
                k--
            }
        }
        stack = append(stack, bytes[i])
    }
    if k > 0 {
        stack = stack[:len(stack) - k]
    }
    for len(stack) > 0 && stack[0] == '0' {
        stack = stack[1:]
    }
    if len(stack) == 0 {
        return "0"
    }
    return string(stack)
}
```

## 4. 类似题目

- LC316
- LC321
- LC402
- LC1081
