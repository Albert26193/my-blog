---
author: Albert
date: 2024-03-30
date created: 2024-01-22
date updated: 2024-01-22 01:11
tags:
  - Blog
  - Algorithm
  - 辅助数组
  - 模板题
title: LC670.最大交换
---

# LC670.最大交换

## 1. 题目

- [670. 最大交换](https://leetcode.cn/problems/maximum-swap/description/)

给定一个非负整数，你**至多** 可以交换一次数字中的任意两位。返回你能得到的最大值。

**示例 1 :**

```
输入:  2736
输出:  7236
解释:  交换数字2和数字7。
```

**示例 2 :**

```
输入:  9973
输出:  9973
解释:  不需要交换。
```

**注意:**

- 给定数字的范围是`[0, 10^8]`

## 2. 思路

- 建立辅助数组 `right`, 其中，`right[i] = k`，代表，所有在 `i` 右侧的数字当中，最大的数字的下标为 `k`。
- 对于某个数，_都可以找到其右侧最大的数字的下标，该操作时间复杂度为 `O(1)`_。
- 从高位开始，遍历数组，如果发现可以交换，那么，就交换，交换完成后 `break`。

## 3. 代码

```go
func maximumSwap(num int) int {
    // 1. num to arr
    arr := make([]int, 0)
    for num > 0 {
        arr = append([]int{num % 10}, arr...)
        num /= 10
    }

    // 2. change arr
    n := len(arr)
    right := make([]int, n)
    rightIndex := n - 1
    // record it
    for i := n - 1; i >= 0; i-- {
        if arr[i] > arr[rightIndex] {
            // fmt.Println(arr[i], arr[rightIndex])
            rightIndex = i
        }

        right[i] = rightIndex
    }

    //fmt.Println(right, arr)
    // change it
    for i := 0; i < n; i++ {
        if arr[right[i]] > arr[i] {
            arr[i], arr[right[i]] = arr[right[i]], arr[i]
            fmt.Println(arr[i], arr[right[i]])
            break
        }
    }

    // 3. arr to num
    ans := 0
    for _, el := range arr {
        ans = ans * 10 + el
    }
    return ans
}
```
