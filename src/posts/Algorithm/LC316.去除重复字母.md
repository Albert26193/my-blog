---
author: Albert
date: 2024-03-28
date created: 2023-05-09
date updated: 2023-01-03 22:22
tags:
  - Blog
  - Algorithm
  - Leetcode
  - 单调栈
title: LC316.去除重复字母
---

# LC316.去除重复字母

## 题目

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小** （要求不能打乱其他字符的相对位置）。

**示例 1：**

```
**输入：** `s = "bcabc"`
**输出`：`** `"abc"`
```

**示例 2：**

`````
**输入：** `s = "cbacdcbc"`
**输出：** `"acdb"````

**提示：**

- `1 <= s.length <= 10^4`
- `s` 由小写英文字母组成
`````

**注意：** 该题与 1081 <a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同

## 思路：有条件的单调栈

- 单调栈参考[[下一个更大数字/LC496.下一个更大元素I]]
- 此题当中，需要保证原来字符串中的每个字符，在新字符串当中，出现且仅出现一次。
- 单调栈的做法，**遍历了原来的字符串**，那么，只需要考虑入栈和出栈的条件即可保证不重不漏。
- 入栈：如果当前栈当中有`currentChar`，那么`currentChar`就是不可以入栈的。通过`vis[26]`数据结构记录当前的单调栈当中是否存在`currentChar`，如果存在，就不具备入栈条件。
- 出栈：如果剩下的字符串当中，没有`stackTop`元素了，那么就不可以将栈顶元素出栈（不然就没有了），所以，需要通过`recordRemain`数据结构，记录剩下的没有遍历到的字符串当中，剩下的各个字母数量。

## 代码

```js
function removeDuplicateLetters(s: string): string {
    let vis: Array<number> = new Array(26).fill(0);
    let recordRemain = new Object();

    s.split("").map((el, index) => {
        if (recordRemain.hasOwnProperty(el)) {
            recordRemain[el] += 1;
        } else {
            recordRemain[el] = 1;
        }
    })

    let stack = new Array();
    for (let i = 0; i < s.length; i++) {
        const currentChar = s[i];
        if (!vis[currentChar.charCodeAt(0) - 'a'.charCodeAt(0)]) {
            while (stack.length && currentChar < stack[stack.length - 1]) {
                if (recordRemain[stack[stack.length - 1]] > 0) {
                    vis[stack[stack.length - 1].charCodeAt(0) - 'a'.charCodeAt(0)] = 0;
                    stack.pop();
                } else {
                    break;
                }
            }
            vis[currentChar.charCodeAt(0) - 'a'.charCodeAt(0)] = 1;
            stack.push(currentChar);
        }

        recordRemain[currentChar] -= 1;

    }

    // console.log(recordRemain);
    return stack.join('');
};
```

---

```go
func removeDuplicateLetters(s string) string {
    mp := make(map[byte]bool)

    n := len(s)
    sta := make([]byte, 0)
    // how much can apply
    remain := make(map[byte]int)

    for i := range s {
        remain[s[i]]++
    }

    for i := 0; i < n; i++ {
        cur := s[i]
        if mp[cur] {
            // why ?
            // cur already in sta and abort cur
            // so -1
            remain[cur] -= 1
            continue
        }

        for len(sta) > 0 && sta[len(sta)-1] > cur {
            staTop := sta[len(sta)-1]

            // have no number to apply
            if remain[staTop] == 0 {
                break;
            } else {
                mp[staTop] = false
                sta = sta[:len(sta)-1]
            }
        }

        // put cur into stack
        sta = append(sta, cur)
        mp[cur] = true
        // remain -= 1
        remain[cur] -= 1
    }

    ans := ""
    for len(sta) > 0 {
        ans = string(sta[len(sta)-1]) + ans
        sta = sta[:len(sta)-1]
    }

    return ans
}
```
