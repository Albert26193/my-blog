---
author: Albert
category: CS-算法
date: 2024-03-30
date created: 2023-05-09
date updated: 2022-12-07 23:10
tags:
  - Blog
  - algorithm
  - 二分查找
  - 辅助数组
title: LC826. 安排工作以达到最大收益
url: https://www.yuque.com/albert-tdjyy/glgpzz/nbgwg3
---

# LC826. 安排工作以达到最大收益

## 1. 题目

[原题链接](https://leetcode.cn/problems/most-profit-assigning-work/)

你有 `n`个工作和 `m` 个工人。给定三个数组：`difficulty`,`profit`和`worker`，其中:

- `difficulty[i]`表示第 `i` 个工作的难度，`profit[i]` 表示第 `i` 个工作的收益。
- `worker[i]` 是第 `i` 个工人的能力，即该工人只能完成难度小于等于 `worker[i]` 的工作。

每个工人**最多**  只能安排 **一个**  工作，但是一个工作可以 **完成多次**  。

- 举个例子，如果 3 个工人都尝试完成一份报酬为 `$1` 的同样工作，那么总收益为 `$3`。如果一个工人不能完成任何工作，他的收益为 `$0` 。

返回 在把工人分配到工作岗位后，我们所能获得的最大利润。

**示例 1：** 

```
输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。
```

**示例 2:** 

```
输入:  difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
输出: 0
```

**提示:** 

- `n == difficulty.length`
- `n == profit.length`
- `m == worker.length`
- `1 <= n, m <= 10^4`
- `1 <= difficulty[i], profit[i], worker[i] <= 10^5` 

## 2. 思路

- 将工作按照难度进行排序。难度越大不一定收益就越多，但是可以在预处理（左边最大值辅助数组）之后，在O(1)时间内得知，满足条件的区间里面最大的收益值是多少。
- 所谓预处理，就是建立一个`left_max`数组，该数组记录了出现在左边的最大值，`left_max[i]`表示从第`0`个位置，到第`i`个位置，出现的最大的数值。
- 对于工人`i`而言，可以通过二分查找，在 `O(lgn)` 时间内找到`difficulty`值不大于`worker[i]`的区间的右端点，该端点记为`x`，那么这个工人能取得的最大收益就是`left_max[x]`。

---

- `left_max`数组预处理，`left_max[i]`表示从`0`到`i`的最大数字

```cpp
vector<int> left_max(n, 0);
left_max[0] = pp[0].second;

for (int i = 1; i < n; i++) {
  left_max[i] = max(left_max[i - 1], pp[i].second);
}
```

- 二分查找，找左侧区间的右端点

```cpp
while (left < right) {
    int mid = (left + right + 1) / 2;
    if (pp[mid].first <= num) {
        left = mid;
    } else {
        right = mid - 1;
    }
}
```

## 3. 代码

```cpp
class Solution {
public:
    int findEnd(int num, vector<pair<int,int>>& pp) {
        int n = pp.size();
        int left = 0, right = n - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (pp[mid].first <= num) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }

        if (pp[right].first <= num) {
            return right;
        } else {
            return -1;
        }
    }

    static bool cmp(const pair<int, int> p1, const pair<int, int> p2) {
        return p1.first < p2.first;
    }
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        int n = difficulty.size();
        vector<pair<int, int>> pp(n, {0, 0});
        for (int i = 0; i < n; i++) {
            pp[i].first = difficulty[i];
            pp[i].second = profit[i];
        }

        sort(pp.begin(), pp.end(), cmp);
        // 对于每个满足条件的条件，计算左边开始的最大收益值
        vector<int> left_max(n, 0);
        left_max[0] = pp[0].second;
        for (int i = 1; i < n; i++) {
            left_max[i] = max(left_max[i - 1], pp[i].second);
        }

        int cnt = 0;
        // 找到满足工人能力条件的区间的右端点，然后计算这个区间曾经出现过的最大值即可
        int worker_num = worker.size();
        for (int i = 0; i < worker_num; i++) {
            int right_end = findEnd(worker[i], pp);
            if (right_end == -1) {
                continue;
            } else {
                cnt += left_max[right_end];
            }
        }

        return cnt;
    }
};
```

---

- `go` 代码如下所示

```go
type pair struct {
    diff int
    profit int
}

func maxProfitAssignment(difficulty []int, profit []int, worker []int) int {
    n := len(difficulty)
    pairs := make([]pair, 0)
    for i := 0; i < n; i++ {
        cur := pair {
            diff: difficulty[i],
            profit: profit[i],
        }

        pairs = append(pairs, cur)
    }

    // sort according to diff
    sort.Slice(pairs, func(i, j int) bool {
        return pairs[i].diff < pairs[j].diff
    })

    // pairs[i], diff==d , profit == p
    // <= diff --> max profit is p
    leftMax := make([]int, n)
    rec := 0
    for i := 0; i < n; i++ {
        if pairs[i].profit > rec {
            rec = pairs[i].profit
        }
        leftMax[i] = rec
    }

    // binary search
    // find last elemnt <= cur worker
    ans := 0
    for _, w := range worker {
        left, right := 0, n - 1
        for left < right {
            mid := (left + right + 1) / 2
            if pairs[mid].diff <= w {
                left = mid
            } else {
                right = mid - 1
            }
        }

        if pairs[right].diff > w {
            continue
        }

        ans += leftMax[right]
    }

    return ans
}
```